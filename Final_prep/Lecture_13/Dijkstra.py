# Описание:
# Алгоритм Дейкстры — это алгоритм нахождения кратчайшего пути от одной вершины до всех остальных вершин в графе с неотрицательными рёбрами. Алгоритм использует жадный подход, поочередно выбирая вершины с минимальной суммой расстояний, и обновляет расстояния до соседних вершин. Этот алгоритм работает на графах, представленных как списки смежности или матрицы смежности, и является одним из самых популярных методов для нахождения кратчайших путей в графах с положительными весами рёбер.
# Основные шаги алгоритма Дейкстры:
# 1.	Инициализация расстояний до всех вершин, кроме начальной, как бесконечности, для начальной вершины — как 0.
# 2.	Использование минимальной очереди для хранения вершин с их текущими кратчайшими расстояниями.
# 3.	Извлечение вершины с минимальным расстоянием и обновление расстояний до её соседей.
# 4.	Повторение шагов 2 и 3 до тех пор, пока не будут обработаны все вершины.
# Алгоритм гарантирует, что мы находим кратчайшие пути от начальной вершины до всех остальных вершин в графе.
# ________________________________________
# Шаги алгоритма Дейкстры:
# 1.	Инициализируем расстояния всех вершин как бесконечность, за исключением начальной вершины, которая имеет расстояние 0.
# 2.	Добавляем начальную вершину в очередь с приоритетом.
# 3.	В цикле извлекаем вершины с минимальным расстоянием из очереди и обновляем расстояния до её соседей, если нахождение пути через эту вершину короче.
# 4.	Продолжаем до тех пор, пока все вершины не будут обработаны.
# Объяснение работы алгоритма:
# 1.	Мы начинаем с вершины 'A', которая имеет расстояние 0.
# 2.	Алгоритм добавляет все её соседние вершины (в данном случае B и C) в очередь с приоритетом, присваивая им расстояния 1 и 4 соответственно.
# 3.	Извлекая вершины из очереди с минимальными расстояниями, алгоритм обновляет расстояния до соседних вершин, если нахождение пути через текущую вершину сокращает расстояние.
# 4.	Алгоритм завершает свою работу, когда все вершины обработаны.
# Сложность алгоритма Дейкстры:
# •	Время: O((V+E)logV), где V — количество вершин, а E — количество рёбер. Время работы алгоритма зависит от операции извлечения минимального элемента из очереди с приоритетом и обновления расстояний.
# •	Память: O(V+E), где V — количество вершин, а E — количество рёбер, поскольку мы храним граф, расстояния и очередь с приоритетом.
# ________________________________________
# Применение алгоритма Дейкстры:
# 1.	Маршрутизация: Применяется для нахождения оптимального пути в сетях, например, в интернет-маршрутизаторах.
# 2.	Планирование путей: Используется в системах навигации для поиска кратчайших путей между точками.
# 3.	Анализ графов: Применяется в задачах, связанных с анализом транспортных сетей, например, для нахождения самых быстрых маршрутов.
# 4.	Оценка стоимости: Может быть использован для расчёта минимальной стоимости достижения целей в задачах оптимизации.
import heapq

def dijkstra(graph, start):
    # Distance from start to each node (default: infinity)
    distances = {node: float('inf') for node in graph}
    distances[start] = 0

    # Min-heap priority queue: (distance, node)
    pq = [(0, start)]

    while pq:
        current_distance, current_node = heapq.heappop(pq)

        # Skip if we've already found a shorter path
        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances
