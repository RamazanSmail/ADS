# Описание:
# Алгоритм Флойда-Уоршелла — это алгоритм нахождения кратчайших путей между всеми парами вершин в графе. В отличие от алгоритма Дейкстры, который находит кратчайший путь от одной вершины ко всем остальным, алгоритм Флойда-Уоршелла находит кратчайшие пути между каждой парой вершин. Он может работать как для графов с положительными, так и с отрицательными рёбрами, при условии, что граф не содержит отрицательных циклов.
# Этот алгоритм используется в задачах, где необходимо узнать кратчайшие расстояния между всеми парами вершин в графе. Алгоритм использует динамическое программирование и обновляет матрицу расстояний, проходя по всем возможным промежуточным вершинам.
# ________________________________________
# Шаги алгоритма Флойда-Уоршелла:
# 1.	Инициализируем матрицу расстояний: для каждой пары вершин (i,j) расстояние dist[i][j] равно весу рёбер между ними, если рёбер нет — бесконечность, а расстояние от вершины до самой себя равно 0.
# 2.	Для каждой промежуточной вершины k обновляем расстояния между всеми парами вершин i и j, проверяя, можно ли улучшить кратчайший путь через k:
# dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])
# 3.	Повторяем это для каждой вершины k, что в итоге даёт нам кратчайшие пути между всеми парами вершин.
# Объяснение работы алгоритма:
# 1.	Инициализация: Сначала создаём матрицу расстояний, где на диагонали находятся нули (расстояние от вершины до самой себя), а для других пар вершин, если существует ребро, мы записываем его вес, иначе — бесконечность.
# 2.	Обновление расстояний: На каждом шаге алгоритм проверяет для каждой пары вершин, можно ли улучшить их расстояние через промежуточную вершину k. Это делается с помощью обновления матрицы расстояний с условием:
# dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])
# 3.	Алгоритм проходит по всем вершинам в качестве промежуточных и обновляет расстояния до всех возможных пар вершин.
# Сложность алгоритма Флойда-Уоршелла:
# •	Время: O(n^3), где n — количество вершин в графе. Это из-за тройного цикла по вершинам для каждого промежуточного шага.
# •	Память: O(n^2), поскольку требуется хранить матрицу расстояний для всех пар вершин.
# Применение алгоритма Флойда-Уоршелла:
# 1.	Графы с отрицательными рёбрами: В отличие от алгоритма Дейкстры, Флойд-Уоршелл может работать с графами, содержащими отрицательные рёбра (при условии, что нет отрицательных циклов).
# 2.	Сетевые задачи: Используется для нахождения кратчайших путей между всеми парами вершин, например, в транспортных или телекоммуникационных сетях.
# 3.	Оптимизация путей: Алгоритм полезен в задачах маршрутизации, где нужно заранее вычислить все кратчайшие пути между парами точек в графе.
# 4.	Теория графов: Часто используется для анализа структуры графов и для нахождения различных характеристик графа, таких как связность или компоненты связности.
def floyd_warshall(graph):
    # Number of vertices
    vertices = list(graph.keys())
    n = len(vertices)
    dist = [[float('inf')] * n for _ in range(n)]
    
    # Map node names to indices
    index = {node: i for i, node in enumerate(vertices)}
    
    # Initialize distances
    for u in graph:
        dist[index[u]][index[u]] = 0  # Distance to self is 0
        for v, w in graph[u]:
            dist[index[u]][index[v]] = w  # Distance from u to v
    
    # Floyd-Warshall main loop
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    # Return result with node names restored
    result = {}
    for i, u in enumerate(vertices):
        result[u] = {}
        for j, v in enumerate(vertices):
            result[u][v] = dist[i][j]
    
    return result
