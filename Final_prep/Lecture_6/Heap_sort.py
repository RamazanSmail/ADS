# Описание: Heap Sort — это алгоритм сортировки, который использует структуру данных кучу для организации элементов. Он работает за счет создания кучи из неотсортированных данных и извлечения элементов из кучи в отсортированном порядке. Суть алгоритма заключается в том, что сначала создается куча, затем поочередно извлекаются наибольший (или наименьший) элемент из кучи и перестраивается оставшаяся часть кучи.
# Алгоритм имеет две основные фазы:
# 1.	Построение кучи: Преобразование входного массива в кучу.
# 2.	Извлечение элементов из кучи: Извлечение корня (максимального или минимального элемента в зависимости от типа кучи), замена его последним элементом в куче и восстановление свойств кучи.
# Алгоритм Heap Sort является неустойчивым, поскольку элементы с одинаковыми значениями могут изменять свой порядок относительно друг друга.
# Принцип работы:
# 1.	Строится куча (max-heap или min-heap), которая организует элементы так, что максимальный (или минимальный) элемент всегда находится на вершине.
# 2.	После этого максимальный (или минимальный) элемент извлекается и помещается в конец массива.
# 3.	Далее восстанавливается структура кучи для оставшихся элементов.
# 4.	Этот процесс повторяется до тех пор, пока все элементы не окажутся отсортированными.
# Сложность:
# •	Время работы:
# o	Построение кучи — O(n).
# o	Извлечение элемента и восстановление кучи —O(log n).
# o	Таким образом, общая сложность алгоритма составляет O(nlog n).
# •	Пространственная сложность: O(1), так как сортировка выполняется на месте, без использования дополнительной памяти, кроме самой кучи.
# Шаги алгоритма Heap Sort:
# 1.	Построение кучи: Преобразуем массив в кучу. Для этого начинаем с последнего узла, который имеет дочерние элементы, и двигаемся к корню, восстанавливая порядок в куче (операция heapify).
# 2.	Извлечение элементов: Извлекаем корень кучи (максимальный или минимальный элемент) и перемещаем его в конец массива. Затем уменьшаем размер кучи и восстанавливаем её свойства
# Преимущества Heap Sort:
# •	Время работы: Алгоритм гарантирует время работы O(nlog n) в худшем, лучшем и среднем случае.
# •	Малая память: Сортировка выполняется "на месте" с использованием постоянной дополнительной памяти, т.е. O(1).
# •	Неустойчивость: Это недостаток, поскольку одинаковые элементы могут менять порядок.
# Недостатки Heap Sort:
# •	Неустойчивость: Порядок элементов с одинаковыми значениями может изменяться после сортировки.
# •	Сложность в реализации: Требует несколько дополнительных шагов для восстановления свойств кучи, что делает его несколько сложнее, чем другие алгоритмы, такие как быстрая сортировка.
# Heap Sort может быть полезен в тех случаях, когда необходимо гарантировать время работы O(nlogn), независимо от исходного порядка элементов, и когда важен малый расход памяти.

def heapify(arr, n, i):
    largest = i          # Initialize largest as root
    left = 2 * i + 1     # left child
    right = 2 * i + 2    # right child

    # See if left child exists and is greater than root
    if left < n and arr[left] > arr[largest]:
        largest = left

    # See if right child exists and is greater than largest so far
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Change root if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root again
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # Build a maxheap (rearrange the array)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements from heap one by one
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # Move current root to end
        heapify(arr, i, 0)

# Example usage
if __name__ == "__main__":
    data = [12, 11, 13, 5, 6, 7]
    print("Original array:", data)
    heap_sort(data)
    print("Sorted array:  ", data)
