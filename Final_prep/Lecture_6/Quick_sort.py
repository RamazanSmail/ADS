# Описание:
# Quick Sort — это один из самых популярных и эффективных алгоритмов сортировки, который использует принцип разделяй и властвуй. Алгоритм работает путем выбора опорного элемента (пивота) в массиве, разделяя массив на две части: одна часть содержит элементы, меньшие опорного, а другая — больше. После этого алгоритм рекурсивно сортирует эти части.
# Быстрая сортировка может работать на любом массиве и имеет эффективную среднюю сложность. Она была предложена Тони Хоаром в 1960 году.
# Принцип работы:
# 1.	Выбирается опорный элемент (пивот). Существует несколько стратегий выбора пивота, например, можно выбрать первый элемент, последний, случайный или медиану.
# 2.	Массив разделяется на два подмассива:
# o	Элементы меньше пивота перемещаются в левую часть массива.
# o	Элементы больше пивота перемещаются в правую часть.
# 3.	После разделения, алгоритм рекурсивно сортирует левую и правую части массива, повторяя процесс.
# Этот процесс продолжается до тех пор, пока подмассивы не станут размером 1 или 0, после чего массив считается отсортированным.
# Сложность:
# •	Средняя сложность: O(nlogn), где n — количество элементов в массиве. Это достигается, когда массив делится на два примерно равных подмассива.
# •	Худший случай: O(n^2), когда опорный элемент выбирается неудачно (например, всегда минимальный или максимальный элемент), и деление массива происходит на один элемент и все остальные элементы.
# •	Лучший случай: O(nlogn), когда массив делится на два равных подмассива.
# •	Пространственная сложность: O(logn) в среднем (для хранения рекурсивных вызовов), и O(n) в худшем случае.
# Шаги алгоритма:
# 1.	Выбор опорного элемента.
# 2.	Разделение массива на две части (по принципу сравнения с опорным элементом).
# 3.	Рекурсивная сортировка двух частей массива. 
# Преимущества Quick Sort:
# •	Средняя сложность O(nlogn): Это очень эффективно по сравнению с другими алгоритмами сортировки, такими как пузырьковая или вставками сортировка.
# •	Очень быстрый на практике: Даже при сравнении с другими алгоритмами сортировки с аналогичной теоретической сложностью, быстрая сортировка часто выигрывает, благодаря меньшему количеству операций по сравнению с другими алгоритмами.
# •	Эффективность при сортировке больших массивов: Это один из самых популярных алгоритмов для сортировки в реальных приложениях.
# Недостатки Quick Sort:
# •	Худший случай O(n^2): Если опорный элемент выбирается неудачно (например, всегда минимальный или максимальный элемент массива), алгоритм может работать гораздо медленнее.
# •	Неустойчивость: Как и многие другие эффективные алгоритмы сортировки, Quick Sort неустойчив, то есть одинаковые элементы могут менять свой порядок относительно друг друга.
# •	Рекурсия: Алгоритм использует рекурсию, что может привести к проблемам с переполнением стека при очень больших массивах.
# Оптимизация Quick Sort:
# 1.	Выбор опорного элемента: Чтобы избежать худшего случая O(n^2), можно использовать различные стратегии выбора опорного элемента, например:
# o	Случайный выбор опорного элемента.
# o	Выбор медианы из первых, последних и средних элементов.
# 2.	Использование хвостовой рекурсии: Рекурсия в одной из частей массива может быть заменена на цикл, что позволит сэкономить память стека.
# Заключение: Quick Sort является одним из самых быстрых и популярных алгоритмов сортировки для работы с большими массивами. Он эффективен в большинстве случаев и часто используется в реальных приложениях, однако, чтобы избежать худшего случая, следует правильно выбирать опорные элементы и оптимизировать алгоритм.

def quick_sort(arr, low, high):
    if low < high:
        # Partition the array and get the pivot index
        pi = partition(arr, low, high)

        # Recursively sort elements before and after partition
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

def partition(arr, low, high):
    pivot = arr[high]  # Choosing the last element as pivot
    i = low - 1        # Pointer for the smaller element

    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]  # Swap

    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # Swap pivot
    return i + 1

# Example usage
if __name__ == "__main__":
    data = [10, 7, 8, 9, 1, 5]
    print("Original array:", data)
    quick_sort(data, 0, len(data) - 1)
    print("Sorted array:  ", data)

