# Описание: Алгоритм Кнута-Морриса-Пратта (KMP) — это эффективный алгоритм поиска подстроки в строке, который использует предварительную обработку шаблона (строки поиска) для ускорения процесса поиска. Алгоритм был разработан Дональдом Кнутом, Vaughan Pratt и James H. Morris в 1977 году и является примером алгоритма с линейной временной сложностью, что делает его значительно быстрее на практике, чем простое переборное решение.
# Вместо того чтобы проверять совпадение каждого символа строки с символами шаблона, алгоритм KMP использует информацию о предыдущих несовпадениях для того, чтобы «перепрыгивать» через части строки, которые уже были проверены и явно не могут привести к совпадению. Это значительно ускоряет поиск.
# Алгоритм KMP:
# 1.	Предобработка шаблона:
# o	В первую очередь, алгоритм строит вспомогательный массив, который называется "префикс-функцией". Этот массив позволяет вычислить, сколько символов шаблона можно пропустить, когда происходит несовпадение символов.
# Префикс-функция для строки — это массив, где каждый элемент p[i] означает длину наибольшего собственного префикса подстроки, заканчивающейся в позиции i, который также является суффиксом этой подстроки. Например, для строки "ABAB" префикс-функция будет выглядеть так: [0, 0, 1, 2].
# 2.	Поиск подстроки в строке:
# o	После того как префикс-функция построена, алгоритм начинает искать вхождение шаблона в строку. При каждом несовпадении алгоритм использует префикс-функцию, чтобы сдвигать шаблон, избегая повторной проверки уже проверенных символов.
# Время работы алгоритма составляет O(n+m), где n — это длина строки, а m — длина шаблона. Таким образом, поиск подстроки становится линейным по времени, что значительно быстрее на больших строках по сравнению с наивным методом (сложность которого O(n⋅m).
# Шаги алгоритма:
# 1.	Преобразование шаблона в префикс-функцию:
# o	Для каждого символа шаблона строится префикс-функция. Она хранит информацию о том, насколько часть шаблона совпадает с его началом.
# 2.	Поиск подстроки:
# o	Процесс поиска состоит в том, чтобы последовательно проверять символы строки с учётом уже найденных совпадений в шаблоне. Если произошел сбой в совпадении, алгоритм сдвигает шаблон на нужную позицию, используя префикс-функцию.
# Применение алгоритма KMP:
# •	Поиск в строках: KMP является эффективным решением для поиска подстроки в строке и используется в различных задачах обработки текста, таких как поиск текста в файлах, анализ текста, редактирование и обработки данных.
# •	Алгоритмы работы с текстами: Алгоритм используется для эффективного поиска и анализа текста в таких приложениях, как редакторы, системы поиска и обработки текстовых данных.
# •	Биоинформатика: В задачах секвенирования генома, где необходимо быстро найти вхождения шаблонов в длинные последовательности ДНК.
# Преимущества:
# 1.	Линейная сложность: Алгоритм KMP работает за время O(n+m), где n — это длина строки, а m — длина шаблона. Это делает его гораздо быстрее, чем наивные алгоритмы, такие как метод "перебора".
# 2.	Эффективность для больших строк: KMP особенно эффективен при работе с длинными строками и многократном поиске одинаковых подстрок.
def compute_lps(pattern):
    """
    Preprocess the pattern to compute the LPS (Longest Prefix Suffix) array.
    """
    m = len(pattern)
    lps = [0] * m
    length = 0  # length of the previous longest prefix suffix

    i = 1
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]  # fall back
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    """
    Returns the starting indices of all occurrences of `pattern` in `text`.
    """
    n = len(text)
    m = len(pattern)
    lps = compute_lps(pattern)
    results = []

    i = j = 0  # i -> text, j -> pattern
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1

        if j == m:
            results.append(i - j)  # Match found
            j = lps[j - 1]  # Look for next match

        elif i < n and text[i] != pattern[j]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return results

# Example usage
text = "ababcabcabababd"
pattern = "ababd"
matches = kmp_search(text, pattern)
print("Pattern found at indices:", matches)
