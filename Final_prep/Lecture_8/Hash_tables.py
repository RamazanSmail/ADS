# Описание:
# Хеш-таблица — это структура данных, которая позволяет эффективно выполнять операции вставки, удаления и поиска элементов. Она работает с использованием хеш-функции, которая преобразует ключ в индекс в массиве, где будет храниться соответствующее значение. Это позволяет получить доступ к данным за амортизированное время O(1) в большинстве случаев.
# Хеш-таблицы широко используются в различных приложениях, таких как базы данных, кэши, анализ данных и многие другие области, где требуется быстрый доступ к данным по ключу.
# Основные операции хеш-таблицы:
# 1.	Вставка (Insert): Добавление нового элемента в хеш-таблицу.
# 2.	Удаление (Delete): Удаление элемента по ключу.
# 3.	Поиск (Search): Поиск элемента по ключу.
# 4.	Обработка коллизий: Когда два ключа хешируются в один и тот же индекс, возникает коллизия. Для её решения используются различные методы, такие как цепочки (chaining) или открытая адресация.
# Как работает хеш-таблица:
# 1.	Хеш-функция: Хеш-функция принимает ключ и преобразует его в индекс массива. Хорошая хеш-функция должна равномерно распределять ключи, чтобы минимизировать количество коллизий.
# 2.	Массив: Массив используется для хранения элементов. Каждый элемент таблицы хранит пару "ключ-значение", где ключ уникален.
# 3.	Коллизии: Если два разных ключа хешируются в один и тот же индекс, это называется коллизией. Коллизии могут быть обработаны разными способами, например, с использованием цепочек или открытой адресации.
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [None] * self.size

    def _hash(self, key):
        # Simple hash function based on built-in hash
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        original_index = index
        while self.table[index] is not None and self.table[index][0] != key:
            index = (index + 1) % self.size
            if index == original_index:
                raise Exception("Hash table is full")

        self.table[index] = (key, value)

    def get(self, key):
        index = self._hash(key)
        original_index = index
        while self.table[index] is not None:
            if self.table[index][0] == key:
                return self.table[index][1]
            index = (index + 1) % self.size
            if index == original_index:
                break
        return None

    def delete(self, key):
        index = self._hash(key)
        original_index = index
        while self.table[index] is not None:
            if self.table[index][0] == key:
                self.table[index] = None
                return True
            index = (index + 1) % self.size
            if index == original_index:
                break
        return False

    def display(self):
        for i, item in enumerate(self.table):
            print(f"Index {i}: {item}")

# Example usage
ht = HashTable()
ht.insert("apple", 100)
ht.insert("banana", 200)
ht.insert("orange", 300)

print("Get apple:", ht.get("apple"))  # 100
ht.delete("banana")

print("Hash Table:")
ht.display()
# Типы коллизий и их обработка:
# 1.	Цепочки (Chaining): Когда несколько элементов хешируются в один и тот же индекс, они сохраняются в списке (или другой структуре) в этом индексе. Этот метод достаточно прост и эффективен, но увеличивает использование памяти.
# 2.	Открытая адресация (Open Addressing): В этом случае, если происходит коллизия, элемент будет вставлен в другой индекс, который ищется по определенному правилу (например, линейное или квадратичное пробирование). Это позволяет избежать использования дополнительной памяти, но усложняет поиск.
# Преимущества хеш-таблиц:
# 1.	Быстрота операций: В среднем операции вставки, удаления и поиска выполняются за время O(1), что делает хеш-таблицы одними из самых быстрых структур данных для этих операций.
# 2.	Гибкость: Хеш-таблицы могут эффективно работать с любыми типами данных в качестве ключей, если имеется подходящая хеш-функция.
# 3.	Использование в реальных приложениях: Хеш-таблицы широко используются в различных областях, например, в реализации кэшей, индексах баз данных, реализации множеств и ассоциативных массивов.
# Недостатки хеш-таблиц:
# 1.	Коллизии: Хеш-функции не всегда могут равномерно распределить элементы по таблице, что приводит к коллизиям. Для их обработки требуются дополнительные ресурсы, что может увеличить время выполнения.
# 2.	Неупорядоченность: Хеш-таблица не поддерживает порядок элементов, как например, дерево или список.
# 3.	Проблемы с памятью: В случае с открытой адресацией таблица может требовать больше памяти, чем ожидалось, особенно при высоком уровне загрузки.
# Применения хеш-таблиц:
# •	Кэширование: Хеш-таблицы эффективно используются в кэшах, где необходимо быстро получать значения по ключу.
# •	Реализация множеств: Для хранения уникальных элементов, например, в реализации множества в языках программирования.
# •	Поиск и индексирование: Хеш-таблицы могут быть использованы для быстрого поиска значений в базе данных или поисковых системах.
# •	Анализ данных: Хеш-таблицы применяются в анализе больших объемов данных для быстрого поиска и обработки информации.
