# Описание:
# Алгоритм Рабина-Карпа — это эффективный алгоритм поиска подстроки в строке, который использует хеширование для быстрого сравнения подстрок с искомым шаблоном. Его основная идея заключается в вычислении хеш-значений подстрок в строке и шаблона, что позволяет сэкономить время на сравнении символов, когда хеш-значения не совпадают. Если хеши совпадают, то происходит проверка символов непосредственно.
# Этот алгоритм особенно эффективен, когда нужно найти все вхождения подстроки в строке или выполнять поиск в больших текстах. Он также подходит для многократных поисков с одним и тем же шаблоном, так как позволяет заранее вычислить хеш шаблона.
# Как работает алгоритм Рабина-Карпа:
# 1.	Предобработка:
# o	Для шаблона и всех возможных подстрок длины, равной длине шаблона в основной строке, вычисляются хеш-значения.
# 2.    Сравнение:
# •	Вычисляется хеш шаблона и хеш каждой подстроки в основной строке.
# •	Если хеши совпадают, то выполняется непосредственная проверка символов подстроки и шаблона. Это необходимо, потому что два разных фрагмента могут иметь одинаковые хеш-значения из-за коллизий.
# •	Если хеши не совпадают, подстрока автоматически отклоняется.
# 3.	  Скользящее окно:
# •	Алгоритм использует технику "скользящего окна", чтобы сдвигать подстроку по строке. При каждом сдвиге вычисляется новый хеш для следующей подстроки с использованием предыдущего хеша, что ускоряет вычисления.
# Алгоритм Рабина-Карпа на практике:
# Алгоритм Рабина-Карпа работает за время O(n⋅m)  в худшем случае, где n — длина строки, а m — длина шаблона. Однако, если использовать хорошую хеш-функцию и уменьшить количество коллизий, можно достичь более эффективного времени работы — O(n+m), что делает алгоритм очень эффективным для многих приложений.
def rabin_karp(text, pattern):
    n = len(text)
    m = len(pattern)
    base = 256  # Number of characters in the input alphabet
    prime = 101  # A prime number to mod hash values (reduce collisions)

    # Precompute base^(m-1) % prime
    h = 1
    for _ in range(m - 1):
        h = (h * base) % prime

    # Compute initial hash values for pattern and text window
    pattern_hash = 0
    window_hash = 0
    for i in range(m):
        pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime
        window_hash = (base * window_hash + ord(text[i])) % prime

    results = []

    # Slide the pattern over the text
    for i in range(n - m + 1):
        if pattern_hash == window_hash:
            # If hash values match, do a character-by-character match
            if text[i:i + m] == pattern:
                results.append(i)

        # Compute hash for next window
        if i < n - m:
            window_hash = (window_hash - ord(text[i]) * h) * base + ord(text[i + m])
            window_hash %= prime
            if window_hash < 0:
                window_hash += prime

    return results

# Example usage
text = "abedabcabcabcabc"
pattern = "abc"
matches = rabin_karp(text, pattern)
print("Pattern found at indices:", matches)
# Преимущества алгоритма Рабина-Карпа:
# 1.	Быстрота для множества поисков: Если шаблон остаётся неизменным, и нужно выполнить несколько поисков в различных строках, алгоритм Рабина-Карпа будет очень эффективен, поскольку хеш шаблона вычисляется один раз, а затем сравнения подстрок можно выполнять за O(1) после каждого сдвига.
# 2.	Многошаблонный поиск: Этот алгоритм можно адаптировать для поиска нескольких шаблонов одновременно, что может быть полезно в задачах, например, поиска различных паттернов в большом тексте.
# 3.	Снижение времени на поиск: При большом количестве совпадений или при работе с большими текстами алгоритм Рабина-Карпа может значительно ускорить поиск, исключая ненужные сравнения символов.
# Недостатки:
# 1.	Коллизии хешей: Алгоритм зависит от качества хеш-функции. В случае частых коллизий (когда два разных фрагмента текста имеют одинаковые хеши), эффективность алгоритма может значительно снизиться, так как потребуется дополнительная проверка символов.
# 2.	Реализация и настройки: Хорошая производительность алгоритма зависит от выбора параметров хеширования (основания p и модуля q), что требует дополнительных вычислений и настроек.
# Применение алгоритма Рабина-Карпа:
# •	Поиск текста: Алгоритм используется для быстрого поиска подстрок в текстах, таких как в текстовых редакторах или при поиске информации в больших документах.
# •	Поиск паттернов в биоинформатике: Рабина-Карпа можно использовать для поиска последовательностей ДНК или белков в базе данных.
# •	Поиск подстрок в строках в реальном времени: В системах, где необходимо постоянно обновлять строку и искать в ней шаблоны, например, в реальном времени на потоках данных.
