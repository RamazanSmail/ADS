# Описание: Топологическая сортировка — это алгоритм упорядочивания вершин в направленном ациклическом графе (DAG, от англ. Directed Acyclic Graph). В топологической сортировке для каждого рёбра (u,v) должно соблюдаться условие, что вершина u предшествует вершине v в результирующем упорядочении.
# Принцип работы:
# •	Алгоритм топологической сортировки используется только для направленных ациклических графов (DAG), то есть для графов, которые не содержат циклов.
# •	Вершины графа упорядочиваются таким образом, что для каждого рёбра u→v, вершина u будет идти перед вершиной v.
# •	Топологическая сортировка может быть полезна, например, при решении задач планирования, таких как упорядочивание задач с зависимостями.
# Основные задачи, решаемые с помощью топологической сортировки:
# 1.	Определение порядка выполнения задач с зависимостями.
# 2.	Планирование операций, где некоторые операции должны быть выполнены до других.
# 3.	Решение задач, связанных с вычислением зависимостей в различных областях (например, компиляция программ).
# Объяснение работы алгоритма:
# 1.	Вначале мы вычисляем степень входа для каждой вершины.
# 2.	В очередь помещаем все вершины с нулевой степенью входа.
# 3.	Извлекаем вершину из очереди, добавляем её в результат и уменьшаем степень входа её соседей.
# 4.	Когда степень входа соседа становится равной нулю, он добавляется в очередь.
# 5.	Если в процессе алгоритма все вершины были добавлены в результат, значит, граф ацикличен, и сортировка возможна.
# 2. Рекурсивная DFS-подход (с использованием стека)
# Этот метод использует обход в глубину для того, чтобы гарантировать, что каждая вершина будет добавлена в результат после обработки всех её соседей.
# Объяснение работы алгоритма:
# 1.	Для каждой вершины выполняется рекурсивный обход в глубину.
# 2.	После того как все соседи вершины будут посещены, вершина добавляется в результат.
# 3.	Поскольку вершины добавляются в результат после обработки всех их соседей, итоговый список будет содержать вершины в топологическом порядке, но в обратном порядке.
# 4.	Мы переворачиваем результат перед его возвращением, чтобы получить правильный порядок.
# Сложность алгоритмов:
# •	Алгоритм Кана:
# o	Время: O(V+E), где V — количество вершин, а E — количество рёбер. Мы посещаем каждую вершину и каждое ребро один раз.
# o	Память: O(V+E) для хранения графа, степеней входа и очереди.
# •	Рекурсивный DFS-подход:
# o	Время: O(V+E), поскольку каждую вершину и ребро посещаем один раз.
# o	Память: O(V) для стека рекурсии и множества посещённых вершин.
# Применение топологической сортировки:
# 1.	Планирование задач с зависимостями: Топологическая сортировка позволяет упорядочить задачи так, чтобы каждая задача выполнялась только после всех зависимых задач.
# 2.	Компиляция программ: В компиляторах топологическая сортировка может использоваться для упорядочивания модулей, чтобы сначала были скомпилированы зависимости, а затем — основной код.
# 3.	Решение зависимости при запросах: При работе с зависимыми запросами в системах баз данных или потоках работы, топологическая сортировка позволяет планировать выполнение с учётом зависимостей.
def topological_sort(graph):
    visited = set()
    stack = []

    def dfs(node):
        visited.add(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs(neighbor)
        stack.append(node)  # Add to stack after visiting all neighbors

    for node in graph:
        if node not in visited:
            dfs(node)

    return stack[::-1]  # Reverse the stack to get the topological order

# Example usage
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}

order = topological_sort(graph)
print("Topological Sort:", order)
