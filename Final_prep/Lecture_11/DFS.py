# Описание: Поиск в глубину (DFS, от англ. Depth-First Search) — это алгоритм обхода графа, который исследует как можно глубже каждый путь перед тем, как вернуться и начать исследовать другие пути. Алгоритм DFS используется для множества задач, таких как проверка связности графа, поиск компонентов связности, нахождение циклов в графе, а также для различных алгоритмов в теории графов.
# Основные особенности:
# •	Принцип работы: Алгоритм начинает с исходной вершины и идет вдоль рёбер к её соседям, углубляясь по графу. Когда он не может углубляться дальше, он возвращается (или "откатывается") и исследует другие ветви.
# •	Порядок посещения: Все возможные вершины на глубину исследуются до тех пор, пока не будет найден конец пути (или не будут исследованы все возможные ветви).
# Применение DFS:
# •	Проверка связности графа.
# •	Поиск компонент связности в неориентированных графах.
# •	Поиск циклов в графах.
# •	Топологическая сортировка в ациклических графах.
# •	Решение задач, таких как нахождение всех путей между двумя вершинами, если граф имеет циклы или направленные рёбра.
# Алгоритм DFS:
# 1.	Начинаем с вершины sss, помечаем её как посещённую.
# 2.	Для каждой непосещённой соседней вершины рекурсивно вызываем DFS.
# 3.	Алгоритм завершится, когда все вершины, достижимые от исходной, будут посещены.
# В отличие от BFS, который использует очередь, DFS обычно использует рекурсию или стек, что позволяет обходить граф до его глубины, прежде чем двигаться дальше.
# Пример:
# Рассмотрим тот же граф:
#      0
#    /   \
#   1     2
#    \   / \
#     3 4   5
# Список смежности для этого графа:
# graph = {
#     0: [1, 2],
#     1: [0, 3],
#     2: [0, 4, 5],
#     3: [1],
#     4: [2],
#     5: [2]
# }
# Объяснение работы кода:
# 1.	Мы начинаем с вершины start_vertex (в данном случае 0).
# 2.	В функцию dfs передаётся вершина, которую нужно исследовать, и множество visited, в котором храним уже посещённые вершины, чтобы избежать зацикливания.
# 3.	Каждый раз, посещая вершину, мы выводим её на экран.
# 4.	Затем рекурсивно вызываем DFS для всех непосещённых соседей вершины.
# Сложность алгоритма DFS:
# •	Время: O(V+E), где V — количество вершин, а E — количество рёбер. Каждый узел и ребро будет посещён не более одного раза.
# •	Память: O(V), поскольку в рекурсивном вызове или стеке необходимо хранить все вершины, которые были посещены.
# Применение DFS:
# 1.	Проверка связности графа:
# o	Чтобы проверить, связан ли граф, достаточно запустить DFS с произвольной вершины. Если после обхода DFS все вершины были посещены, то граф связан.
# 2.	Поиск компонент связности:
# o	Если граф не связан, мы можем запустить DFS с каждой непосещённой вершины, чтобы найти все компоненты связности.
# 3.	Поиск циклов в графе:
# o	DFS позволяет легко обнаружить циклы в графах, особенно в направленных графах, используя "обратные" рёбра и отслеживая состояние вершины (посещена ли она, в процессе ли она обработки или завершена).
# 4.	Топологическая сортировка:
# o	В ациклических направленных графах DFS может быть использован для топологической сортировки (расставления вершин в порядок, который соответствует направлению рёбер).
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def dfs_tree(node):
    if node is None:
        return
    print(node.value, end=' ')
    dfs_tree(node.left)
    dfs_tree(node.right)

# Example usage
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print("DFS Traversal of Binary Tree (Preorder):")
dfs_tree(root)  # Output: 1 2 4 5 3
