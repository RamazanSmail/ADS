# Описание: Поиск в ширину (BFS, от англ. Breadth-First Search) — это алгоритм для обхода графа, который посещает все вершины на текущем уровне (ширине) перед тем, как перейти к следующему уровню. Он используется для нахождения кратчайших путей в графах с одинаковыми весами рёбер, а также для решения различных задач, связанных с графами, таких как проверка связности графа или нахождение компонент связности.
# Основные особенности:
# •	Принцип работы: Алгоритм начинается с одной вершины, исследует все её соседние вершины, а затем переходит к их соседям. Он использует очередь (FIFO) для хранения вершин, которые предстоит посетить.
# •	Порядок посещения: Вершины, которые находятся ближе к исходной вершине, будут посещены первыми.
# Применение BFS:
# •	Нахождение кратчайшего пути в графах с одинаковыми весами рёбер.
# •	Проверка связности графа (если все вершины графа могут быть достигнуты из одной вершины).
# •	Поиск компонент связности в неориентированных графах.
# •	Поиск всех возможных путей в графе (например, для задач планирования).
# Алгоритм BFS:
# 1.	Начинаем с вершины s, добавляем её в очередь.
# 2.	Пока очередь не пуста:
# o	Извлекаем вершину u из очереди.
# o	Посещаем все её соседние вершины, которые ещё не были посещены, и добавляем их в очередь.
# Для удобства реализации можно использовать множество visited для отслеживания посещённых вершин, чтобы избежать зацикливания и многократного посещения одной и той же вершины.
# Пример:
# Рассмотрим граф:
#      0
#    /   \
#   1     2
#    \   / \
#     3 4   5
# Список смежности для этого графа:
# graph = {
#     0: [1, 2],
#     1: [0, 3],
#     2: [0, 4, 5],
#     3: [1],
#     4: [2],
#     5: [2]
# }
# Сложность алгоритма BFS:
# •	Время: O(V+E), где V — количество вершин, а E — количество рёбер. Мы посещаем каждую вершину и каждое ребро не более одного раза.
# •	Память: O(V), поскольку нам нужно хранить информацию о всех вершинах в множестве visited и в очереди.
# Применение BFS:
# 1.	Поиск кратчайшего пути в графе с одинаковыми весами рёбер:
# o	BFS находит кратчайший путь в графе, если все рёбра графа имеют одинаковый вес (например, если граф невзвешенный).
# 2.	Проверка связности графа:
# o	Если после выполнения BFS все вершины графа будут посещены, то граф связан (то есть существует путь между любыми двумя вершинами).
# 3.	Нахождение компонент связности:
# o	Если граф не связан, можно запустить BFS с каждой непосещённой вершины, чтобы найти все компоненты связности в графе.
# 4.	Поиск в лабиринте:
# o	Алгоритм BFS может использоваться для поиска кратчайшего пути в лабиринте, где каждая клетка представляет вершину, а рёбра — это возможные переходы между соседними клетками.
from collections import deque

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def bfs_tree(root):
    if not root:
        return

    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node.value, end=' ')
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

# Example usage
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print("BFS Traversal of Binary Tree:")
bfs_tree(root)  # Output: 1 2 3 4 5
