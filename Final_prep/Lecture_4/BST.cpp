// Описание: Двоичное поисковое дерево (Binary Search Tree, BST) — это тип двоичного дерева, в котором для каждого узла выполнено следующее условие:
// •	Все элементы в левом поддереве узла меньше значения этого узла.
// •	Все элементы в правом поддереве узла больше значения этого узла.
// Такое дерево организует данные таким образом, чтобы обеспечивать быстрый поиск, вставку и удаление элементов, особенно в отсортированных наборах данных.
// Структура:
// •	Корень: первый элемент дерева, с которого начинается поиск.
// •	Левый поддерево: все элементы, меньшие родительского узла.
// •	Правый поддерево: все элементы, большие родительского узла.
// •	Листья: узлы, не имеющие потомков.
// Основные операции:
// 1.	Поиск: поиск элемента в дереве начинается с корня, и на каждом шаге решается, двигаться ли в левое или правое поддерево в зависимости от значения искомого элемента.
// 2.	Вставка: новый элемент добавляется в дерево в соответствии с правилами размещения в левом или правом поддереве.
// 3.	Удаление: удаление элемента из дерева требует учета трех случаев:
// o	Удаление узла, не имеющего потомков (листьев).
// o	Удаление узла с одним потомком.
// o	Удаление узла с двумя потомками (необходимо найти его преемника или предшественника для корректного удаления).
// Пример: Предположим, у нас есть последовательность чисел:
// [50, 30, 70, 20, 40, 60, 80]
// И мы строим бинарное поисковое дерево:
// 1.	50 — корень.
// 2.	30 — меньше 50, поэтому в левое поддерево.
// 3.	70 — больше 50, в правое поддерево.
// 4.	20 — меньше 50 и 30, в левое поддерево от 30.
// 5.	40 — меньше 50, но больше 30, в правое поддерево от 30.
// 6.	60 — больше 50, но меньше 70, в левое поддерево от 70.
// 7.	80 — больше 50 и 70, в правое поддерево от 70.
// Получаем дерево:
//         50
//        /  \
//      30    70
//     /  \   /  \
//    20  40 60   80
// Алгоритм вставки:
// 1.	Начинаем с корня.
// 2.	Если новый элемент меньше текущего узла, идем в левое поддерево.
// 3.	Если новый элемент больше текущего узла, идем в правое поддерево.
// 4.	Повторяем, пока не найдем пустое место для вставки.
// Сложности:
// •	Поиск: O(log n) в среднем, где n — количество элементов в дереве. Однако, если дерево сбалансировано, поиск работает быстро. В худшем случае (когда дерево вырождается в линейную структуру) время поиска может быть O(n).
// •	Вставка: O(logn) в среднем.
// •	Удаление: O(logn) в среднем.
// Применение:
// •	Индексация: Бинарные деревья поиска часто используются в базах данных для быстрого поиска данных.
// •	Алгоритмы сортировки: Деревья поиска могут использоваться для реализации сортировки.
// •	Обработка запросов: В системах, которые требуют быстрого поиска, например, в сетях маршрутизации или в поисковых системах.
// Преимущества:
// •	Быстрый доступ к данным при условии, что дерево сбалансировано.
// •	Простота реализации и хорошая производительность для операций поиска, вставки и удаления в сбалансированных деревьях.
// Недостатки:
// •	Если дерево сильно несбалансированно (например, при вставке отсортированных данных), его структура может превратиться в линейную цепочку, что снизит производительность.
// •	Для предотвращения этого существуют балансирующие деревья, такие как AVL-деревья или красно-черные деревья, которые автоматически балансируют себя при каждой вставке и удалении.

#include <iostream>
using namespace std;

struct Node{
    int data; //that stores a value
    Node* left; //left child
    Node* right; //right child
};

Node* createNode(int data){                                                                               
    Node* newNode = new Node();                                                                          
    newNode->data = data;                                                                               
    newNode->left = nullptr;  //because we dont have left and right childrens now                       
    newNode->right = nullptr;                                                                         
    return newNode;
}

int main(){
    //     1      We are creating such a binary tree
    //    / \
    //   2  3
    //  / 
    // 4

    Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);


    //Notice!!!: Binary tree can have only <=2 childrens, BST has same rule but also
    //should be like this form
    //       root
    //      /    \
    //  <=root   >root       right subtree should be always bigger, left subtree less or equal

    return 0;
}