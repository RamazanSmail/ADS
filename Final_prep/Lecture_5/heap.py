# Описание:
# Куча — это структура данных, которая реализует приоритетную очередь. Основной особенностью кучи является поддержание свойства упорядоченности, которое гарантирует, что каждый родительский элемент удовлетворяет определенному порядку относительно своих дочерних элементов. В кучах различают две основные формы: max-heap (максимальная куча), где родительский элемент больше или равен своим детям, и min-heap (минимальная куча), где родительский элемент меньше или равен своим детям.
# Куча представляется как бинарное дерево, в котором каждый узел имеет не более двух дочерних элементов. Однако дерево всегда сбалансировано (или почти сбалансировано), что позволяет эффективно выполнять операции вставки и извлечения элементов.
# Типы куч:
# •	Max-heap (Максимальная куча): в этой куче значение родительского элемента всегда больше или равно значениям его детей. Таким образом, на вершине кучи всегда находится максимальный элемент.
# •	Min-heap (Минимальная куча): в этой куче значение родительского элемента всегда меньше или равно значениям его детей, поэтому на вершине кучи всегда находится минимальный элемент.
# Операции с кучей:
# 1.	Вставка элемента (Insert):
# o	Элемент добавляется в конец кучи (как в полный бинарный дерево), а затем происходит "подъем" элемента вверх, чтобы восстановить свойства кучи. Этот процесс называется heapify-up.
# 2.	Извлечение максимального или минимального элемента (Extract-Max или Extract-Min):
# o	В случае max-heap извлекается корень, который содержит наибольшее значение. После извлечения корень заменяется последним элементом кучи, а затем выполняется операция heapify-down для восстановления свойств кучи.
# o	В случае min-heap извлекается корень с минимальным значением и выполняется аналогичная операция.
# 3.	Просмотр максимального или минимального элемента (Peek):
# o	Это операция, которая позволяет посмотреть значение корня без его извлечения.
# Алгоритмы, основанные на кучах:
# •	Алгоритм сортировки на основе кучи (Heap Sort): используется для сортировки элементов с помощью максимальной или минимальной кучи. Алгоритм включает в себя несколько этапов: создание кучи и извлечение максимальных или минимальных элементов для их сортировки.
# •	Алгоритм Дейкстры: для поиска кратчайших путей в графе, где на каждом шаге извлекается вершина с минимальным расстоянием.
# •	Алгоритм Хаффмана: используется в сжимающих алгоритмах для эффективного кодирования, где часто используются кучи для создания оптимального дерева Хаффмана.
# Основные операции с кучей:
# •	Вставка элемента —O(logn).
# •	Извлечение элемента (извлечение максимального или минимального) —O(logn).
# •	Просмотр корня (максимального или минимального элемента) —O(1).
# •	Построение кучи из набора данных —O(n) (с использованием метода "снизу вверх").
# Реализация кучи: Кучу можно реализовать с использованием массива, где для каждого элемента индекс родителя и детей можно вычислить с помощью простых математических формул:
# •	Индекс родителя: parent(i)=⌊2i−1⌋/2
# •	Индекс левого ребенка: left(i)=2i+1
# •	Индекс правого ребенка: right(i)=2i+2
class MinHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left_child(self, i):
        return 2 * i + 1

    def right_child(self, i):
        return 2 * i + 2

    def insert(self, key):
        self.heap.append(key)
        self._heapify_up(len(self.heap) - 1)

    def _heapify_up(self, i):
        while i != 0 and self.heap[self.parent(i)] > self.heap[i]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)

    def extract_min(self):
        if not self.heap:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()

        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_down(self, i):
        smallest = i
        left = self.left_child(i)
        right = self.right_child(i)

        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left

        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right

        if smallest != i:
            self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i]
            self._heapify_down(smallest)

    def get_min(self):
        return self.heap[0] if self.heap else None

    def __str__(self):
        return str(self.heap)

# Example usage:
if __name__ == "__main__":
    h = MinHeap()
    h.insert(5)
    h.insert(3)
    h.insert(8)
    h.insert(1)
    print("Heap:", h)
    print("Extracted min:", h.extract_min())
    print("Heap after extraction:", h)
