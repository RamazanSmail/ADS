# Описание: Очередь с приоритетом (Priority Queue) — это структура данных, в которой каждый элемент имеет приоритет, и элементы с более высоким приоритетом извлекаются раньше, чем элементы с более низким приоритетом, независимо от их порядка добавления. Основное отличие от обычной очереди, где элементы извлекаются в том порядке, в котором они были добавлены (FIFO), заключается в том, что здесь извлечение происходит на основе приоритета.
# Основные операции:
# 1.	Enqueue: Добавление элемента в очередь с приоритетом. Элемент добавляется в очередь с определённым уровнем приоритета.
# 2.	Dequeue: Извлечение элемента с наивысшим приоритетом.
# 3.	Peek: Просмотр элемента с наивысшим приоритетом без его извлечения.
# 4.	Change priority: Изменение приоритета элемента в очереди.
# Реализация: Очередь с приоритетом может быть реализована с использованием различных структур данных, например:
# 1.	Массив или Список: Элементы сохраняются в массиве или списке, и каждый раз при добавлении элемента сортируется очередь, что даёт сложность операции извлечения O(1), но сложность вставки — O(n).
# 2.	Куча (heap): Обычно используется двоичная куча (или мин-куча/макс-куча). В куче элементы упорядочиваются так, что извлечение элемента с наивысшим приоритетом происходит за время O(log n), а вставка нового элемента также выполняется за O(logn).
# 3.	Бинарное дерево поиска: Может быть использовано для хранения элементов с приоритетами, но чаще применяется куча из-за меньшей сложности операций.
# Сложности:
# •	Enqueue (вставка): В куче операция вставки происходит за O(logn), так как для поддержания свойств кучи требуется перестроение.
# •	Dequeue (извлечение): Операция извлечения также происходит за O(logn) в куче, так как необходимо извлечь корень (максимум или минимум) и затем перешифровать дерево.
# •	Peek (просмотр): O(1), так как наивысший приоритетный элемент всегда находится в корне кучи.
# •	Change priority: Если нужно изменить приоритет элемента, то операция может потребовать удаления элемента и последующей вставки, что может занять O(logn).
# Типы очередей с приоритетом:
# 1.	Макс-очередь (Max-Heap): Элементы с наивысшим приоритетом находятся в корне, и извлекаются первым. Например, это используется в задачах, где нужно всегда извлекать самый "высокий" элемент.
# 2.	Мин-очередь (Min-Heap): Элементы с наименьшим приоритетом находятся в корне. Это используется, например, в алгоритмах поиска кратчайшего пути (как в алгоритме Дейкстры).
# 3.	Упорядоченная очередь: Элементы сохраняются в отсортированном порядке, что позволяет быстро извлекать наивысший элемент, но операция вставки может быть медленной.
# Применение:
# 1.	Алгоритм Дейкстры: Очередь с приоритетом используется для поиска кратчайших путей в графах с положительными весами рёбер. Очередь хранит вершины, упорядоченные по расстоянию от начальной вершины.
# 2.	Планирование задач в операционных системах: Очередь с приоритетом используется для управления процессами, где задачи с более высоким приоритетом выполняются раньше.
# 3.	Анализ данных: Очередь с приоритетом может быть полезна для обработки данных в реальном времени, где нужно обрабатывать важные события или запросы в первую очередь.
# Преимущества:
# •	Быстрая обработка элементов с наивысшим приоритетом.
# •	Хорошо подходит для задач с динамически изменяющимся приоритетом.
# Недостатки:
# •	Время работы вставки и извлечения может быть менее эффективным для больших наборов данных по сравнению с обычной очередью (FIFO).
# •	Для обновления приоритета элементов требуется удаление и повторная вставка, что может повлиять на производительность.
# Очереди с приоритетом — это мощный инструмент для оптимизации задач, где порядок выполнения операций зависит от важности или приоритета каждого элемента.

import heapq

# Initialize an empty priority queue (min-heap)
priority_queue = []

# Insert elements with their priorities
heapq.heappush(priority_queue, (2, 'Task A'))  # Priority 2
heapq.heappush(priority_queue, (1, 'Task B'))  # Priority 1 (higher priority)
heapq.heappush(priority_queue, (3, 'Task C'))  # Priority 3

# Retrieve and remove the highest priority element (smallest priority value)
task = heapq.heappop(priority_queue)
print(task)  # Output: (1, 'Task B')

# Peek at the highest priority element
print(priority_queue[0])  # Output: (2, 'Task A')


