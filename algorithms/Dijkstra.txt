def find_min(d, was):
    min = INT_MAX
    min_index = -1

    for(i = 0; i < n; i++):
        if(d[i] < min && was[i] == 0): //если расстояние до вершины меньше минимума и она является не посещенной
            min = d[i] 
            min_index = i
        return min_index

was[1, n] = 0    //посещеннная вершина
d[1, n] = infinity
d[s] = 0  //дистанция стартовой вершины
for(int i = 0; i < n; i++):
    V = find_min(d, was) //вершина это минимальная дистанция 
    for (u, w) in G[V]:  
        if(d[u] > d[v] + w):  //если индекс соседа больше индекса текущей вершины то добавляем к своему весу дополнительный
            d[u] = d[v] + w   
            pr[u] = V

В данном алгоритме нам даются вершины и они соеденены гранями с разным весом, мы отмечаем вес начальной вершины
как 0, а остальные неизвестными, далее мы выбираем грань с самым маленьким весом, до другой вершины. Далее снова
через самую малую вершину выбираем кратчайший путь и при надобности обновляем вершину если нашелся путь меньше
чем тот который был до этого. 
Time complexity: O(n^2 + m) - basic
Time complexity: O(n + mlogm) or O(mlogn) - improved by priority queue

